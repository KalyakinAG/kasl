//@skip-check module-structure-top-region

#Область KASL

#Область СериализацияXML

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Выполняет преобразование (десериализацию) XML-строки в значение.
// См. также ЗначениеВСтрокуXML.
//
// Параметры:
//  СтрокаXML - Строка - XML-строка, с сериализованным объектом..
//
// Возвращаемое значение:
//  Произвольный - значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает XML-представление XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO  - объект, для которого требуется сформировать XML-представление.
//  Фабрика    - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XML-представление.
//                             Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   Строка - XML-представление XDTO-объекта.
//
Функция ОбъектXDTOВСтрокуXML(Знач ОбъектXDTO, Знач Фабрика = Неопределено) Экспорт
	
	ОбъектXDTO.Проверить();
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, ОбъектXDTO, , , , НазначениеТипаXML.Явное);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Формирует XDTO-объект по XML-представлению.
//
// Параметры:
//  СтрокаXML - Строка    - XML-представление XDTO-объекта,
//  Фабрика - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XDTO-объект.
//                          Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//  ОбъектXDTO - XDTO-объект.
//
Функция ОбъектXDTOИзСтрокиXML(Знач СтрокаXML, Знач Фабрика = Неопределено) Экспорт
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Чтение = Новый ЧтениеXML();
	Чтение.УстановитьСтроку(СтрокаXML);
	
	Возврат Фабрика.ПрочитатьXML(Чтение);
	
КонецФункции

#КонецОбласти

#Область СериализацияJSON

// Преобразует значение в строку JSON при помощи метода глобального контекста ЗаписатьJSON.
// Допускаются не все типы значений, подробности см. в синтакс-помощнике.
// Даты преобразуются в формат ISO (YYYY-MM-DDThh:mm:ssZ).
// 
// Параметры:
//  Значение - Произвольный
//
// Возвращаемое значение:
//  Строка
//
Функция ЗначениеВJSON(Знач Значение, КрасивоеФорматирование = Ложь) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	Если КрасивоеФорматирование Тогда
		ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, "    ", Истина));
	Иначе
		ЗаписьJSON.УстановитьСтроку();
	КонецЕсли;
	ЗаписатьJSON(ЗаписьJSON, Значение);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Преобразует строку в формате JSON в значение при помощи метода глобального контекста ПрочитатьJSON.
// См. ограничения в синтакс-помощнике.
// Объекты JSON по умолчанию преобразует в значения типа Соответствие. 
// Имена свойств со значением типа Дата необходимо явно указывать, чтобы было выполнено преобразование.
// Ожидаемый формат дат - ISO (YYYY-MM-DDThh:mm:ssZ).
// 
// Параметры:
//   Строка - Строка - значение в формате JSON.
//   ИменаСвойствСоЗначениямиДата - Строка - имя свойства, содержащее значение типа Дата. Допустимо указывать несколько
//                                           свойств через запятую.
//                                - Массив из Строка 
//   ПрочитатьВСоответствие       - Булево - если Ложь, то объекты JSON будут преобразованы в значение типа Структура.
//   
// Возвращаемое значение:
//  Произвольный
//
Функция JSONВЗначение(Знач Строка, Знач ИменаСвойствСоЗначениямиДата = Неопределено, Знач ПрочитатьВСоответствие = Истина) Экспорт
	
	Если ТипЗнч(ИменаСвойствСоЗначениямиДата) = Тип("Строка") Тогда
		ИменаСвойствСоЗначениямиДата = СтрРазделить(ИменаСвойствСоЗначениямиДата, ", " + Символы.ПС, Ложь);
	КонецЕсли;
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	
	Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие, ИменаСвойствСоЗначениямиДата);
	
КонецФункции

Функция ПрочитатьЗначениеJSONИзФайла(ИмяФайла) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ИмяФайла, "UTF-8");
	Значение = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();
	Возврат Значение;
КонецФункции

Процедура ЗаписатьЗначениеJSONВФайл(Значение, ИмяФайла) Экспорт
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина);
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ИмяФайла, "UTF-8", , ПараметрыJSON);
	ЗаписатьJSON(ЗаписьJSON, Значение);
	ЗаписьJSON.Закрыть();
КонецПроцедуры

Функция ПрочитатьЗначениеJDTOИзФайла(ИмяФайла) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ИмяФайла, "UTF-8");
	Значение = СериализаторXDTO.ПрочитатьJSON(ЧтениеJSON);
	Возврат Значение;
КонецФункции

Процедура ЗаписатьЗначениеJDTOВФайл(Значение, ИмяФайла) Экспорт
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина);
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ИмяФайла, "UTF-8", , ПараметрыJSON);
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Значение, НазначениеТипаXML.Явное);
	ЗаписьJSON.Закрыть();
КонецПроцедуры

#КонецОбласти

Функция УстановитьЧисловоеЗначение(СсылкаНаЗначение, Значение) Экспорт
	Дельта = Значение - СсылкаНаЗначение;
	СсылкаНаЗначение = Значение;
	Возврат Дельта;
КонецФункции

Функция ПредставлениеСтруктуры(Элемент) Экспорт
	Поля = РаботаСМассивом.АТДМассив(Элемент)
		.Отобразить("СтрШаблон('%1: """"%2""""', Элемент.Ключ, Строка(Элемент.Значение))")
		.ВМассив()
	;
	Представление = "{
	|	" + СтрСоединить(Поля, Символы.ПС + Символы.Таб) + "
	|}";
	Возврат Представление;
КонецФункции

Функция ВставитьСвойство(Приемник, Свойство, Значение) Экспорт
	Приемник.Вставить(Свойство, Значение);
	Возврат Приемник;
КонецФункции

// Возвращает значение второго параметра в случае, если значение первого параметра NULL.
// В противном случае будет возвращено значение первого параметра
//
// Параметры:
//  ПроверяемоеЗначение  - произвольный тип - проверяемое значение
//  ВозвращаемоеЗначение - произвольный тип - возвращаемое значение, если значение ПроверяемоеЗначение есть NULL
//
// Возвращаемое значение:
//  ПроверяемоеЗначение - если его значение не NULL, ВозвращаемоеЗначение - в ином случае.
//
Функция ЕстьNull(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если ПроверяемоеЗначение = Null Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

Функция ЕстьПустоеЗначение(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если Не ЗначениеЗаполнено(ПроверяемоеЗначение) Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

// Возвращает массив в свойств. Требования к свойствам такие же как при объявлении структуры.
// 
// Параметры:
//	Значение	- Строка - свойства через запятую 
//              - Массив - возвращается в исходном массиве
// Возвращаемое значение:
//	Массив - массив свойств
//
Функция Массив(Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения = Тип("Массив") Тогда
		Возврат Значение;
	КонецЕсли;
	Если ТипЗначения = Тип("Строка") И НЕ ПустаяСтрока(Значение) Тогда
		Возврат СтрРазделить(СтрЗаменить(СтрЗаменить(Значение, " ", ""), Символы.ПС, ""), ",", Ложь);
	КонецЕсли;
	Возврат Новый Массив;
КонецФункции

//  Преобразование текста HTML в форматированную строку
//
//  Поддерживаются теги:
//    <p> - абзац
//    <br> - перевод строки
//    <n> - шрифт без оформления
//    <b> - жирный шрифт
//    <i> - наклонный шрифт
//    <u> - подчеркнутый шрифт
//    <s> - зачеркнутый шрифт
//    <img src = "{ИмяКартинкиИзБиблиотекиКартинок}">
//  Поддерживаются стили: 
//    font-weight: bold|normal
//    font-style: italic|normal
//    text-decoration: underline|line-through|none
//    font-family: {ИмяШрифта}
//    font-size: {РазмерШрифта}
//    font-scale: {МасштабШрифта}
//    color: {ЦветТекста}
//    background-color: {ЦветФона}
//  Примеры:
//    <i color="blue">Цветная</i>
//    <span style="font-size: 18">Меняем размер шрифта</span>
//    <span style="font-family: consolas">Меняем шрифт</span>
//    <span style="background-color: yellow; color: red">красный текст на <i>желтом</i> фоне</span>
//
//  Параметры:
//  ТекстHTML - Строка - Строка в формате HTML
//  Вложения - Структура - 
//		* Ключ - имя картинки в HTML, 
//		* Значение - картинка
//
Функция HTMLШаблон(ТекстHTML, Знач Вложения = Неопределено) Экспорт
	Вложения = ?(Вложения = Неопределено, Новый Структура, Вложения);
	ФорматированныйДокумент = Новый ФорматированныйДокумент;
	ФорматированныйДокумент.УстановитьHTML(ТекстHTML, Вложения);
	Возврат ФорматированныйДокумент.ПолучитьФорматированнуюСтроку();
КонецФункции

Функция CamelCase(Строка) Экспорт
	Состав = СтрРазделить(Строка, " ", Ложь);
	Для й = 0 По Состав.ВГраница() Цикл
		Слово = Состав[й];
		Состав[й] = ВРег(Лев(Слово, 1)) + НРег(Прав(Слово, СтрДлина(Слово) - 1));
	КонецЦикла;
	Возврат СтрСоединить(Состав, "");
КонецФункции

Функция ФорматДатаВремя(ДатаВремя) Экспорт
	СоставДаты = Новый Массив;
	СоставДаты.Добавить(Год(ДатаВремя));
	СоставДаты.Добавить(Месяц(ДатаВремя));
	СоставДаты.Добавить(День(ДатаВремя));
	Если НачалоДня(ДатаВремя) <> ДатаВремя Тогда
		СоставДаты.Добавить(Час(ДатаВремя));
		СоставДаты.Добавить(Минута(ДатаВремя));
		СоставДаты.Добавить(Секунда(ДатаВремя));
	КонецЕсли;
	Возврат СтрЗаменить("ДАТАВРЕМЯ("+СтрСоединить(СоставДаты, ",")+")", Символы.НПП, "");
КонецФункции

Функция ЭкранироватьТекст(Знач ТекстоваяСтрока) Экспорт
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, Символы.ПС, Символы.ПС+"|");
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, """", """""");
	Возврат ТекстоваяСтрока;
КонецФункции

// Возвращает эквивалент имени по значению уникального идентификатора
//
// Параметры:
//  УИД - Уникальный идентификатор - Значение уникального идентификатора
//
// Возвращаемое значение:
//   Имя - Строка, удовлетворяющая требованиям имен переменных
//
Функция ИмяПоУникальномуИдентификатору(Знач УИД = Неопределено) Экспорт
	Если УИД = Неопределено Тогда
		УИД = Новый УникальныйИдентификатор;
	КонецЕсли;
	Возврат "_" + СтрЗаменить(Строка(УИД), "-", "_");
КонецФункции

Функция ОкончаниеСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СКонца)+1);
КонецФункции

Функция НачалоСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СНачала)+1);
КонецФункции

Функция ПолучитьТекстОшибок(Ошибки, Отказ = Ложь) Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат "";
	Иначе
		Отказ = Истина;
	КонецЕсли; 
	ТекстОшибок = "";
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			ТекстОшибок = ТекстОшибок + Символы.ПС + Ошибка.ТекстДляОднойОшибки;
		Иначе
			Текст = ?(ПустаяСтрока(Ошибка.ТекстДляНесколькихОшибок), Ошибка.ТекстДляОднойОшибки, Ошибка.ТекстДляНесколькихОшибок);
			ТекстОшибок = ТекстОшибок + Символы.ПС + СтрЗаменить(Текст, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ="));
		КонецЕсли;
	КонецЦикла;
	ТекстОшибок = Прав(ТекстОшибок, СтрДлина(ТекстОшибок)-1);
	Возврат ТекстОшибок;
КонецФункции

// Выводит накопленные методом ДобавитьОшибкуПользователю ошибки, при этом использует нужные шаблоны текстов ошибок
// в зависимости от количества однотипных ошибок.
//
// Параметры:
//  Ошибки  - Неопределено, Структура - коллекция ошибок.
//  Отказ - Булево - устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Ошибки, Отказ = Ложь, Заголовок = "", Подвал = "") Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер Тогда
		МодульОбщегоНазначения = ОбщегоНазначения;
	#Иначе
		МодульОбщегоНазначения = ОбщегоНазначенияКлиент;
	#КонецЕсли
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Отступ = "	";
		
		МодульОбщегоНазначения.СообщитьПользователю(Заголовок, Неопределено, "");
	Иначе
		Отступ = "";
	КонецЕсли;
	Отказ = Истина;
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			МодульОбщегоНазначения.СообщитьПользователю(
				Отступ + Ошибка.ТекстДляОднойОшибки,
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		Иначе
			МодульОбщегоНазначения.СообщитьПользователю(
				Отступ + СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(Подвал) Тогда
		МодульОбщегоНазначения.СообщитьПользователю(Подвал, Неопределено, "");
	КонецЕсли;
	
КонецПроцедуры

#Если НЕ ВебКлиент Тогда
	
Функция ОбъектВJSON(Объект, ПараметрыЗаписиJSON = Неопределено) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(?(ПараметрыЗаписиJSON = Неопределено, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина), ПараметрыЗаписиJSON));
	ЗаписатьJSON(ЗаписьJSON, Объект);
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

Функция JSONВОбъект(СтрокаJSON, ПрочитатьВСоответствие = Ложь) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
КонецФункции

Функция ЗначениеВJDTO(Значение) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Значение, НазначениеТипаXML.Явное);
	Строка = ЗаписьJSON.Закрыть();
	Возврат Строка;
КонецФункции

Функция JDTOВЗначение(Строка) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	Значение = СериализаторXDTO.ПрочитатьJSON(ЧтениеJSON);
	Возврат Значение;
КонецФункции

#КонецЕсли // НЕ ВебКлиент

Функция ЭтоJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "{" ИЛИ ПервыйСимвол = "[" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Функция ЭтоСтруктураJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "{" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Функция ЭтоМассивJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "[" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Функция СтруктураРазличий(Структура1, Структура2) Экспорт
	Перем Значение;
	//:Структура1 = Новый Структура;
	//:Структура2 = Новый Структура;
	СтруктураРазличий = Новый Структура;
	Для Каждого ЭлементСтруктуры Из Структура1 Цикл
		Если Не Структура2.Свойство(ЭлементСтруктуры.Ключ, Значение) ИЛИ Значение <> ЭлементСтруктуры.Значение Тогда
			СтруктураРазличий.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Для Каждого ЭлементСтруктуры Из Структура2 Цикл
		Если Не Структура1.Свойство(ЭлементСтруктуры.Ключ, Значение) ИЛИ Значение <> ЭлементСтруктуры.Значение Тогда
			СтруктураРазличий.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат СтруктураРазличий;
КонецФункции

Функция СтруктурыИдентичны(Структура1, Структура2) Экспорт
	Возврат СтруктураРазличий(Структура1, Структура2).Количество() = 0;
КонецФункции

//  Устанавливает значение переданной переменной только если есть различие. Возвращает различие.
Функция УстановитьЗначение(СсылкаНаЗначение, Значение, ЗаполнятьПустое = Истина, СохранятьТип = Ложь) Экспорт
	Если Ложь
		ИЛИ СсылкаНаЗначение = Значение
		ИЛИ (Истина
			И НЕ ЗаполнятьПустое
			И НЕ ЗначениеЗаполнено(Значение)
		)
	Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТипСсылки = ТипЗнч(СсылкаНаЗначение);
	Если ТипСсылки = Неопределено Тогда
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;
		
	ТипЗначения = ТипЗнч(Значение);
	Если Истина
		И (Ложь 
			ИЛИ ТипСсылки = Тип("Структура") 
			ИЛИ ТипСсылки = Тип("ФиксированнаяСтруктура") 
		)
		И (Ложь 
			ИЛИ ТипЗначения = Тип("Структура") 
			ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура") 
		)
	Тогда
		Если СтруктурыИдентичны(СсылкаНаЗначение, Значение) Тогда
			Возврат Ложь;
		КонецЕсли;
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;
	
	Если ТипСсылки = ТипЗначения ИЛИ НЕ СохранятьТип Тогда
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;			
	
	ОписаниеТипа = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипСсылки));
	ПриведенноеЗначение = ОписаниеТипа.ПривестиЗначение(Значение);
	Если СсылкаНаЗначение = ПриведенноеЗначение Тогда
		Возврат Ложь;	
	КонецЕсли;
	СсылкаНаЗначение = ПриведенноеЗначение;
	Возврат Истина;
КонецФункции

Процедура ДобавитьЗначениеВСтруктуруПараметров(Параметры, ЗначениеПараметра, ПутьКДанным = "") Экспорт
	СоставПути = СтрРазделить(ПутьКДанным, ".");
	Значение = Параметры;
	ИмяПараметра = СоставПути[СоставПути.ВГраница()]; 
	Для Индекс = 0 По СоставПути.ВГраница() - 1 Цикл
		Путь = СоставПути[Индекс];		
		Если НЕ Параметры.Свойство(Путь, Значение) Тогда
			Значение = Новый Структура;
			Параметры.Вставить(Путь, Значение);
		КонецЕсли;
	КонецЦикла;
	Значение.Вставить(ИмяПараметра, ЗначениеПараметра);
КонецПроцедуры

//  Возвращает массив с элементами, различными между массивами (исключающее ИЛИ, взято с http://www.forum.mista.ru/topic.php?id=750240)
Функция МассивРазличий(Массив1, Массив2) Экспорт
	Результат = Новый Массив;
	Повтор = Новый Соответствие;
	Для каждого Элемент Из Массив1 Цикл
		Повтор[Элемент] = ?(Повтор[Элемент] = Неопределено, Ложь, Истина)
	КонецЦикла;
	Для каждого Элемент Из Массив2 Цикл
		Повтор[Элемент] = ?(Повтор[Элемент] = Неопределено, Ложь, Истина)
	КонецЦикла;
	Для каждого Элемент Из Повтор Цикл
		Если НЕ Элемент.Значение Тогда
			Результат.Добавить(Элемент.Ключ)
		КонецЕсли
	КонецЦикла;
	Возврат Результат
КонецФункции

//  Сравнивает массивы/фиксированные массивы по различиям. Повторы значения не являются различием.
// В отличии от ОбщегоНазначенияКлиентСервер.СпискиЗначенийИдентичны может работать также с фиксированными массивами
Функция МассивыИдентичны(Массив1, Массив2) Экспорт
	Возврат (МассивРазличий(Массив1, Массив2).ВГраница() = -1);
КонецФункции

Функция СтруктураСвойств(Свойства, Источник) Экспорт
	Результат = Новый Структура(Свойства);
	ЗаполнитьЗначенияСвойств(Результат, Источник);
	Возврат Результат;
КонецФункции

// Возвращает УникальныйИдентификатор по его эквиаленту имени (строковому представлению без "-")
//
// Параметры:
//  Имя - Строка - Эквиалент имени уникального идентификатора
//
// Возвращаемое значение:
//  УникальныйИдентификатор
Функция УникальныйИдентификаторПоИмени(Имя) Экспорт
	Возврат Новый УникальныйИдентификатор(СтрЗаменить(Прав(Имя, 36), "_", "-"));
КонецФункции

Функция СловарьОтображенияСвойств(Свойства) Экспорт
	Если ТипЗнч(Свойства) = Тип("Структура") Тогда
		Возврат Свойства;
	КонецЕсли;
	Словарь = Новый Структура;
	Для Каждого Свойство Из РаботаСМассивом.Массив(Свойства) Цикл
		Состав = СтрРазделить(Свойство, "= ", Ложь);
		Если Состав.Количество() = 1 Тогда
			Состав.Добавить(Состав[0]);						
		КонецЕсли;
		Словарь.Вставить(Состав[1], Состав[0]);
	КонецЦикла;
	Возврат Словарь;
КонецФункции

Функция ОтобразитьСвойства(Значение, Свойства) Экспорт
	СловарьОтображения = СловарьОтображенияСвойств(Свойства);
	НовоеЗначение = Новый Структура();
	Для Каждого Отображение Из СловарьОтображения Цикл
		НовоеЗначение.Вставить(Отображение.Значение, Значение[Отображение.Ключ]);
	КонецЦикла;
	Возврат НовоеЗначение;
КонецФункции

Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = ПолучитьРазделительПути();
	
	Если СтрЗаканчиваетсяНа(ПутьКаталога, ДобавляемыйСимвол) Тогда
		Возврат ПутьКаталога;
	Иначе 
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	КонецЕсли;
КонецФункции

// Объединить пути.
// 
// Параметры:
//  Путь1 - Строка - Путь1
//  Путь2 - Строка - Путь2
//  Путь3 - Строка - Путь3
//  Путь4 - Строка - Путь4
//  Путь5 - Строка - Путь5
// 
// Возвращаемое значение:
//  Строка - Объединенный путь
Функция ОбъединитьПути(Путь1, Путь2, Путь3 = "", Путь4 = "", Путь5 = "") Экспорт
	Разделитель = ПолучитьРазделительПути();
	Состав = Новый Массив;
	Если ЗначениеЗаполнено(Путь1) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь1));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь2) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь2));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь3) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь3));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь4) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь4));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь5) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь5));
	КонецЕсли;
	Возврат СтрСоединить(Состав);
КонецФункции

Функция ФайлСуществует(Знач ПутьДляСохранения) Экспорт
	ПроверкаФайла = Новый Файл(ПутьДляСохранения);
	Если Не ПроверкаФайла.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ПроверкаФайла.ЭтоФайл() Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

#КонецОбласти // KASL
